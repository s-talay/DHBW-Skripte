import hashlib

def Hash(message):
    sha256 = hashlib.sha256()
    sha256.update(message.encode('utf-8'))
    sha256_hex = sha256.hexdigest()
    return sha256_hex
def erweiterterEuklid(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        ggT, x, y = erweiterterEuklid(b % a, a)
        return (ggT, y - (b // a) * x, x)
def inversesImMod(a, m):
    ggT, x, _ = erweiterterEuklid(a, m)
    if ggT != 1:
        raise ValueError("Die Zahlen sind nicht teilferfremd")
    else:
        return x % m
    
n = 0x00ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551

m1 = "Kryptologie DHBW Mannheim"
e1 = int(Hash(m1), 16)
r1 = 0x8ceb3fae0e393ec4dad49b31e9f891feada04ced09bec2d1aec5e06382fc5fe3
s1 = 0x4d39ea9f39ef9362de7145d95f53840c28c64f1fc84124a43c3d3f47a6c32f78

m2 = "Kryptologie DHBW Mannheim 2023"
e2 = int(Hash(m2), 16)
r2 = 0x8ceb3fae0e393ec4dad49b31e9f891feada04ced09bec2d1aec5e06382fc5fe3
s2 = 0x208eed4c39f3e21295b8653be86476b4b0995f3dac27e281df5d6f678f80ed2a

# Formel aus Vorlesung
zähler = s2*e1-s1*e2
nenner = s1*r1-s2*r1
d = (zähler)/(nenner) % n
if(isinstance(d,float)):
    d = zähler*inversesImMod(nenner,n) % n
print(hex(d)) #Output = 0x202068747470733a2f2f796f7574752e62652f4a2d2d2d6169797a6e47512020

